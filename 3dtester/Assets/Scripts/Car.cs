using UnityEngine;
using System.Collections;

/// <summary>
/// The car!
/// It's a machine that offers mobility via centripedal motion of "tires" attached to a body through a smaller machine known as an "engine".
/// One can enter the body of this device, allowing them to partake in the motion generated by the machine, significantly enhancing their ability to move to places.
/// ... ... ...
/// ... ... ...
/// ... But really, it's just an object that moves, turns, and takes inputs from a player or the computer.
/// </summary>
public class Car : MonoBehaviour 
{
    /// <summary>
    /// How long the car has been in an upside-down position
    /// </summary>
    public float flippedTime = 0;
    /// <summary>
    /// How long the car has not been in motion.
    /// </summary>
    public float immobileTime = 0;

    public float topSpeed = 150;
    internal float currentSpeed;
	public float maxReverseSpeed = -50;
	public float maxTurnAngle = 10;
	public float maxTorque = 10;
	public float decelerationTorque = 30;
	public Vector3 centerOfMassAdjustment = new Vector3(0f,-0.9f,0f);
	public float spoilerRatio = 0.1f;
	internal WheelCollider wheelFL;
    internal WheelCollider wheelFR;
    internal WheelCollider wheelBL;
    internal WheelCollider wheelBR;
    internal Transform wheelTransformFL;
    internal Transform wheelTransformFR;
    internal Transform wheelTransformBL;
    internal Transform wheelTransformBR;
	private Rigidbody body;

    public float maxBrakeTorque = 100f;
    public bool applyHandbrake = false;

    public float handbrakeForwardSlip = 0.04f;
    public float handbrakeSidewaySlip = 0.08f;


    /// <summary>
    /// The "way" this car is controlled.
    /// Depending which object it is given, the way the car is controlled may change.
    /// </summary>
    public InputControl input;
    
    /// <summary>
    /// The collider that allows this car to trigger waypoints.
    /// </summary>
    internal BoxCollider waypointCollider;

    void Start()
    {
        gameObject.layer = Helper.LAYER_CAR;


        //lower center of mass for roll-over resistance
        body = GetComponent<Rigidbody>();
		body.centerOfMass += centerOfMassAdjustment;
        body.maxAngularVelocity = 100f;


        wheelTransformFR = this.transform.Find("WheelsHubs").Find("WheelHubFrontRight");
        wheelTransformFL = this.transform.Find("WheelsHubs").Find("WheelHubFrontLeft");
        wheelTransformBR = this.transform.Find("WheelsHubs").Find("WheelHubRearRight");
        wheelTransformBL = this.transform.Find("WheelsHubs").Find("WheelHubRearLeft");
        //
        wheelFR = wheelTransformFR.gameObject.GetComponent<WheelCollider>();
        wheelFL = wheelTransformFL.gameObject.GetComponent<WheelCollider>();
        wheelBR = wheelTransformBR.gameObject.GetComponent<WheelCollider>();
        wheelBL = wheelTransformBL.gameObject.GetComponent<WheelCollider>();


        waypointCollider = gameObject.GetComponent<BoxCollider>();
        if (waypointCollider != null) { Debug.LogError("A Box Collider was already assigned to the car (there should be none)"); }
        waypointCollider = gameObject.AddComponent<BoxCollider>();
        waypointCollider.center = new Vector3(0, 1, 0);
        waypointCollider.size = new Vector3(0.1f, 0.1f, 0.1f);

    }
	
	// FixedUpdate is called once per physics frame
	void FixedUpdate () 
	{
        input.Read(this);
        

        if (input.inputBrake)
        {
            applyHandbrake = true;
            wheelFL.brakeTorque = maxBrakeTorque;
            wheelFR.brakeTorque = maxBrakeTorque;

            if (GetComponent<Rigidbody>().velocity.magnitude > 1)
            {
                SetSlipValues(handbrakeForwardSlip, handbrakeSidewaySlip);
            }
            else
            {
                SetSlipValues(1f, 1f);
            }
        }
        else
        {
            applyHandbrake = false;
            wheelFL.brakeTorque = 0;
            wheelFR.brakeTorque = 0;
            SetSlipValues(1f, 1f);
        }


        //calculate max speed in KM/H (optimized calc)
        currentSpeed = wheelBL.radius * wheelBL.rpm * Mathf.PI * 0.12f;

        // *** If airborne...
        if (!(wheelBL.isGrounded || wheelBR.isGrounded || wheelFL.isGrounded || wheelFR.isGrounded))
        {
            body.AddRelativeTorque(-3000f * input.inputTorque, 0, -3000f * input.inputSteer);

            // *** Is the car flipped over?
            if (Mathf.DeltaAngle(transform.localEulerAngles.x, 0) > 90 || Mathf.DeltaAngle(transform.localEulerAngles.z, 0) > 90)
            {
                flippedTime += Time.deltaTime;
            }
            else
            {
                flippedTime = 0;
            }

            immobileTime = 0;
        }
        // *** If grounded...
        else
        {
            flippedTime = 0;

            // ??? <-- Sorta arbitrary, but SHOULD work... I hope.
            // *** If we are moving, then we aren't immobile... DUH!
            if (body.velocity.magnitude > 0.1f)
            {
                immobileTime = 0;
            }
            else
            {
                immobileTime += Time.deltaTime;
            }


            if (currentSpeed < topSpeed && currentSpeed > maxReverseSpeed)
            {
                //rear wheel drive.
                wheelBL.motorTorque = input.inputTorque * maxTorque;
                wheelBR.motorTorque = input.inputTorque * maxTorque;
            }
            else
            {
                //can't go faster, already at top speed that engine produces.
                wheelBL.motorTorque = 0;
                wheelBR.motorTorque = 0;
            }

            //Spoilers add down pressure based on the carâ€™s speed. (Upside-down lift)
            Vector3 localVelocity = transform.InverseTransformDirection(body.velocity);
            body.AddForce(-transform.up * (localVelocity.z * spoilerRatio), ForceMode.Impulse);

            //front wheel steering
            wheelFL.steerAngle = input.inputSteer * maxTurnAngle;
            wheelFR.steerAngle = input.inputSteer * maxTurnAngle;

            //apply deceleration when not pressing the gas or when breaking in either direction.
            if (!applyHandbrake && ((input.inputTorque <= -0.5f && localVelocity.z > 0) || (input.inputTorque >= 0.5f && localVelocity.z < 0)))
            {
                wheelBL.brakeTorque = decelerationTorque + maxTorque;
                wheelBR.brakeTorque = decelerationTorque + maxTorque;
            }
            else if (!applyHandbrake && input.inputTorque == 0)
            {
                wheelBL.brakeTorque = decelerationTorque;
                wheelBR.brakeTorque = decelerationTorque;
            }
            else
            {
                wheelBL.brakeTorque = 0;
                wheelBR.brakeTorque = 0;
            }
        }


        //
        if (input.inputReset)
        {
            InvalidPosReset();
        }
    }
	
    void SetSlipValues(float forward, float sideways)
    {
        WheelFrictionCurve tempStruct;
        tempStruct = wheelBR.forwardFriction;
        tempStruct.stiffness = forward;
        wheelBR.forwardFriction = tempStruct;
        //
        tempStruct = wheelBR.sidewaysFriction;
        tempStruct.stiffness = sideways;
        wheelBR.sidewaysFriction = tempStruct;


        tempStruct = wheelBL.forwardFriction;
        tempStruct.stiffness = forward;
        wheelBL.forwardFriction = tempStruct;
        //
        tempStruct = wheelBL.sidewaysFriction;
        tempStruct.stiffness = sideways;
        wheelBL.sidewaysFriction = tempStruct;
    }

	void UpdateWheelPositions()
	{
		//move wheels based on their suspension.
		WheelHit contact = new WheelHit();
		if(wheelFL.GetGroundHit(out contact))
		{
			Vector3 temp = wheelFL.transform.position;
			temp.y = (contact.point + (wheelFL.transform.up*wheelFL.radius)).y;
			wheelTransformFL.position = temp;
		}
		if(wheelFR.GetGroundHit(out contact))
		{
			Vector3 temp = wheelFR.transform.position;
			temp.y = (contact.point + (wheelFR.transform.up*wheelFR.radius)).y;
			wheelTransformFR.position = temp;
		}
		if(wheelBL.GetGroundHit(out contact))
		{
			Vector3 temp = wheelBL.transform.position;
			temp.y = (contact.point + (wheelBL.transform.up*wheelBL.radius)).y;
			wheelTransformBL.position = temp;
		}
		if(wheelBR.GetGroundHit(out contact))
		{
			Vector3 temp = wheelBR.transform.position;
			temp.y = (contact.point + (wheelBR.transform.up*wheelBR.radius)).y;
			wheelTransformBR.position = temp;
		}
	}
	
	void Update()
	{
        // ??? <-- Messy and seems to cause cars to bounce and shoot into the air
        // ... Likely because the wheel's colliders are rolling against the floor, spiking the car into the air...
        return;
		//rotate the wheels based on RPM
		float rotationThisFrame = 360*Time.deltaTime;
		wheelTransformFL.Rotate(wheelFL.rpm/rotationThisFrame,0,0);
		wheelTransformFR.Rotate(wheelFR.rpm/rotationThisFrame,0,0);
		wheelTransformBL.Rotate(wheelBL.rpm/rotationThisFrame,0,0);
		wheelTransformBR.Rotate(wheelBR.rpm/rotationThisFrame,0,0);

		UpdateWheelPositions();
	}




    /// <summary>
    /// Reset the car's position.
    /// Also reorients the car and nullifies its momentum.
    /// </summary>
    public void InvalidPosReset()
    {
        GameManager gm = GameManager.Instance();
        
        
        body.velocity = Vector3.zero;
        body.angularVelocity = Vector3.zero;
        //
        Transform waypoint = gm.raceWaypoints.waypoints[input.currentWaypoint];
        transform.localRotation = waypoint.localRotation;
        transform.position = waypoint.position;


        immobileTime = 0;
        flippedTime = 0;
    }
}
